<div dir="rtl">

## عنوان تمرین: مقایسه معماری‌های دارای گیت (LSTM، GRU و BiLSTM) 
هدف کلی: پیاده‌سازی و مقایسه چهار معماری Simple RNN، LSTM، GRU و BiLSTM برای پیش‌بینی سری زمانی به منظور درک عملکرد مکانیزم‌های گیت و شناسایی تفاوت‌های عملی آن‌ها.

### ۱. تنظیمات و پیش‌پردازش داده‌ها

-   **دیتاست:** مجموعه داده "Household Electric Power Consumption" از Kaggle.
    
-   **معماری مدل‌ها:** همه مدل‌ها باید دارای **دو لایه بازگشتی با ۶۴ واحد مخفی** در هر لایه و یک لایه تمام‌متصل (Fully Connected) برای خروجی باشند.
    
-   **روش ورودی:** استفاده از پنجره لغزان (Sliding Window) با **۶۰ گام زمانی (Timestep)** برای پیش‌بینی گام ۶۱.
    
-   **تقسیم داده‌ها:** ۷۰٪ آموزش، ۱۵٪ اعتبارسنجی (Validation) و ۱۵٪ تست (با حفظ ترتیب زمانی).
    
-   **پیش‌پردازش:** نرمال‌سازی ویژگی‌ها (استانداردسازی با میانگین صفر و واریانس یک) که پارامترهای آن فقط روی مجموعه آموزش محاسبه شود.
    
-   **هایپرپارامترها:** یکسان برای تمام مدل‌ها (نرخ یادگیری، اندازه Batch، بهینه‌ساز Adam و تعداد Epochها).
    

----------

### ۲. بخش‌های تمرین

#### **الف) جدول مقایسه جامع عملکرد**

پس از آموزش مدل‌ها، باید آن‌ها را روی داده‌های تست ارزیابی کرده و جدولی شامل موارد زیر تهیه کنید:

1.  میانگین مربعات خطا (MSE) و میانگین قدر مطلق خطا (MAE) روی تست.
    
2.  میانگین زمان آموزش هر Epoch (ثانیه).
    
3.  تعداد کل پارامترهای قابل آموزش.
    
4.  سرعت همگرایی (تعداد Epoch لازم برای رسیدن به ۹۰٪ بهترین عملکرد اعتبارسنجی).
    

**سوالات تحلیلی:**

-   کدام معماری بهترین توازن بین دقت، هزینه محاسباتی و سرعت را دارد؟
    
-   آیا بهبود عملکرد احتمالی BiLSTM نسبت به LSTM ارزش دو برابر شدن پارامترها را دارد؟
    
-   در چه سناریوهایی (با توجه به محدودیت زمان آموزش و استقرار) GRU ترجیح داده می‌شود؟
    

#### **ب) بصری‌سازی مکانیزم گیت‌ها**

باید کدی بنویسید که مقادیر فعال‌سازی گیت‌های داخلی را هنگام استنتاج استخراج کند:

-   **برای LSTM:** گیت‌های Input، Forget و Output.
    
-   **برای GRU:** گیت‌های Update و Reset.
    
-   **روش:** انتخاب ۳ توالی نمونه (طول ۶۰) از داده‌های تست و رسم Heatmap یا نمودار خطی (محور افقی: زمان، محور عمودی: نوع گیت، رنگ/ارتفاع: مقدار فعال‌سازی بین ۰ تا ۱).
    

**سوالات تحلیلی:**

-   گیت Forget در LSTM چه زمانی به ۱ (یادآوری) و چه زمانی به ۰ (فراموشی) نزدیک می‌شود و چه اتفاقی در ورودی رخ داده است؟
    
-   الگوهای فعال‌سازی گیت‌های GRU (Update/Reset) چگونه با گیت‌های LSTM (Forget/Input) مقایسه می‌شوند؟ آیا همبسته‌اند یا مستقل؟
    
-   شناسایی زمان‌هایی که مدل تصمیم به یادآوری اطلاعات مهم می‌گیرد و ارتباط آن با مقادیر واقعی سری زمانی.
    

#### **پ) آزمایش وابستگی بلندمدت**

طراحی آزمایشی برای بررسی عملکرد مدل‌ها در طول توالی‌های مختلف:

-   ایجاد سه نسخه از دیتاست با طول توالی **۳۰، ۶۰ و ۱۲۰**.
    
-   آموزش مدل‌های جداگانه برای هر طول (با معماری ثابت) و ثبت خطای تست.
    
-   رسم نمودار (محور افقی: طول توالی، محور عمودی: خطا) با ۴ خط برای معماری‌ها.
    

**سوالات تحلیلی:**

-   ارائه شواهد کمی مبنی بر حفظ عملکرد بهتر معماری‌های گیت‌دار نسبت به Simple RNN در توالی‌های بلند.
    
-   محاسبه افت عملکرد با افزایش طول از ۳۰ به ۱۲۰؛ کدام معماری پایدارتر است؟
    
-   آیا BiLSTM برتری خود را در توالی‌های بلند حفظ می‌کند؟ آیا GRU با پارامتر کمتر توانایی LSTM در مدیریت توالی بلند را دارد؟
    

#### **ت) تحلیل نقادانه دو طرفه بودن (Bi-directionality)**

مقایسه LSTM تک‌جهته با BiLSTM:

-   تحلیل کنید آیا دسترسی BiLSTM به گام‌های زمانی آینده (Future Timesteps) در حین آموزش، یک سناریوی غیرواقعی ایجاد می‌کند؟
    
-   آیا عملکرد بهتر روی تست به استقرار واقعی منتقل می‌شود؟ (با توجه به عدم دسترسی به آینده در پیش‌بینی واقعی) .
    
-   مقایسه این موضوع با "طبقه‌بندی متن" که در آن کل توالی در دسترس است و توضیح اینکه چرا BiLSTM برای پیش‌بینی سری زمانی ممکن است مشکل‌ساز باشد.
    

#### **ث) بررسی حذف گیت (Ablation Study)**

پیاده‌سازی سه نسخه تغییر یافته از LSTM برای درک اهمیت گیت‌ها:

1.  LSTM با **فقط Forget Gate** فعال (Input و Output همیشه ۱).
    
2.  LSTM با **فقط Input Gate** فعال (Forget و Output همیشه ۱).
    
3.  LSTM کامل (هر سه گیت فعال).
    

**سوالات تحلیلی:**

-   رتبه‌بندی نسخه‌ها بر اساس خطای تست.
-   کدام گیت حیاتی‌تر است؟ اگر حذف یک گیت باعث افت شدید شد، نقش آن چیست؟
-   آیا نتایج با انتظارات نظری شما از نقش گیت‌ها مطابقت دارد؟

</div>
